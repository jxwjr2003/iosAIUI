# iOS UI 编辑器技术设计文档

## Context
需要创建一个基于 Web 的 iOS UI 层级编辑器，支持可视化编辑复杂的 UI 组件树。该项目基于以下完整的 JSON 数据格式标准，需要实现四区域界面、实时预览、数据导入导出等功能。

**技术约束**：
- 使用原生 Web 技术栈（JavaScript、CSS、HTML）
- 不依赖任何前端框架
- 支持复杂 UI 层级树的流畅编辑（最多1000个节点，响应时间小于100ms）
- 严格遵循以下 JSON 格式标准
- 使用 Electron 桌面应用框架，适合跨平台桌面工具使用

## Goals / Non-Goals

### Goals
- 实现可拖拽的四区域布局（左侧35%、中间30%、右侧35%、底部AI聊天区域）
- 支持多根节点的树形结构编辑
- 实时预览选中的 UI 组件（基于 CSS 的 Web 模拟）
- 完整的节点属性编辑（基础属性、样式、约束、函数）
- JSON 数据导入导出功能（支持选择性展示根节点）
- 自动节点 ID 生成系统（030201 格式）
- 集成 AI 聊天助手，通过 Electron 主进程连接 AI 服务器
- **输出标准化的 JSON 数据结构，不生成任何代码**

### Non-Goals
- **不生成任何 iOS/Swift 代码**
- 不实现真实的 iOS 原生渲染
- 不实现完整的 UIKit 组件库
- 不依赖第三方 UI 框架
- 不实现用户认证和云端存储
- 不提供完整的 AI 模型训练功能
- **不涉及任何编程语言代码生成**

## Decisions

### 1. 架构模式：模块化设计
**决策**：采用模块化架构，将功能拆分为独立模块
- `TreeEditor` - 树形编辑器
- `Simulator` - iOS 模拟器
- `PropertyEditor` - 属性编辑器
- `DataManager` - 数据管理
- `StateManager` - 状态管理
- `AIChatAssistant` - AI 聊天助手

**替代方案考虑**：
- 单体架构：代码耦合度高，难以维护
- 框架依赖：违反技术约束

### 2. 树形编辑器交互设计
**决策**：采用直观的树形交互设计，支持完整的节点操作
- **默认展开策略**：所有节点及子节点默认完全展开，平铺展示完整层级结构
- **节点操作按钮**：每个节点右侧显示操作按钮组（添加子节点、删除节点、复制节点、粘贴子节点）
- **组件类型选择**：添加子节点时弹出组件类型选择对话框，支持30+种iOS组件类型
- **复制粘贴机制**：深度复制包含所有子节点，粘贴时自动刷新节点ID和重置约束关系
- **实时同步**：节点选择时属性编辑器立即显示对应节点信息，确保多面板数据一致性
- **模拟器联动**：节点选择时模拟器实时预览选中的根节点，支持子节点修改时的根节点溯源展示

**替代方案**：
- 折叠显示：用户需要手动展开节点，操作繁琐
- 上下文菜单：操作隐藏，不如直接按钮直观
- 固定组件类型：灵活性不足，无法扩展

**理由**：提供最直观的操作体验，减少用户操作步骤，确保编辑效率，保持与模拟器的紧密集成

### 2. 属性编辑器交互设计
**决策**：采用直观的属性编辑界面，支持完整的节点属性配置
- **基础信息区域**：
  - 节点ID自动显示（只读，030201格式），提供复制功能
  - 节点名称可编辑，实时同步到树形编辑器
  - 节点类型选择器支持30+种UIKit组件类型，包含完整的基础UIKit类型列表
  - 根节点类型同步：所有根节点都是UI组件库，根节点名称修改后自动同步到类型选择器
- **Attributes属性管理**：
  - 颜色属性支持16进制（#RRGGBB格式）和RGB（0-255数值）输入，带实时颜色预览方块
  - 默认attributes为空对象，提供"新增属性"按钮
  - 根据节点类型显示常见属性列表，支持自定义属性（key、value、type）
  - 属性key唯一性验证，防止重复key
- **约束包管理系统**：
  - 默认约束包为空，第一个创建的约束包标记为默认约束包
  - 支持约束包的新增、命名、删除操作
  - 约束配置流程：选择约束类型（size、edge、center、baseline、aspectRatio）→ 选择方法 → 设置数值 → 选择参考节点（仅父节点和兄弟节点）
  - 系统级约束冲突检测，实时提示冲突信息
- **成员变量管理**：
  - 支持新增、编辑、删除成员变量
  - 手动输入变量名称、选择类型（String、Int、Bool、Double、Float、UIColor、UIFont等）、设置默认值
  - 类型验证和默认值格式检查
- **函数和协议管理**：
  - functions/eventFunctions格式：包含funcName、funcLogic字段
  - protocols格式：包含protocolName、protocolLogic字段
  - 支持新增、编辑、删除操作
- **布局和备注**：
  - 子节点布局选择器：horizontal（横向）或 vertical（竖向），默认horizontal，仅当有子节点时生效
  - 备注字段（description）：多行文本输入框，用于节点功能说明

**替代方案**：
- 固定属性面板：灵活性不足，无法支持自定义属性
- 单一约束数组：难以管理复杂的约束组合
- 无类型验证：数据格式容易出错

**理由**：提供完整的属性编辑能力，支持灵活的自定义配置，确保数据格式的正确性和一致性

### 3. 数据模型：标准化 JSON 格式
**决策**：采用标准化的 JSON 数据格式（详细定义见 `data-management` 规范）
- 严格遵循定义的 JSON Schema，使用 AJV (Another JSON Schema Validator) 进行实时验证
- 支持多根节点树形结构，每个根节点独立管理其子节点层级
- 使用层级节点 ID 系统（0101 格式），实现自动生成和重新编号算法
- 类型化的属性定义（string、number、color、boolean、array、object 等）
- 组件特定属性模板，为每个 UIKit 组件类型预定义常见属性，支持属性继承和覆盖
- 成员变量系统支持自定义变量定义（String、Int、Bool、Double、Float、UIColor、UIFont 等），包含类型验证和默认值管理
- 约束包系统支持完整的约束类型（尺寸、边界、中心、基线、宽高比），包含约束冲突检测和解决方案
- 新增description字段用于节点备注说明
- 更新functions/eventFunctions格式为{funcName, funcLogic}
- 更新protocols格式为{protocolName, protocolLogic}

**理由**：确保数据格式的标准化和一致性，提供直观的属性编辑体验，便于数据交换和版本管理

**技术实现细节**：
- **JSON Schema 验证**：定义完整的 JSON Schema 规范，包括节点结构、属性类型、约束格式等
- **节点 ID 重新编号算法**：当节点被删除时，自动重新计算所有受影响的节点 ID，保持层级编码的连续性
- **属性类型验证**：对每个属性值进行类型检查，确保数据格式正确
- **约束冲突检测**：实时检测约束包中的冲突约束，提供自动解决建议
- **颜色格式转换**：支持16进制和RGB格式的相互转换和验证
- **根节点类型同步**：实现根节点名称修改时的类型选择器自动更新机制

**约束冲突检测算法**：
- **过度约束检测**：识别同一维度上的多个约束（如同时设置top和bottom约束）
- **约束矛盾检测**：识别相互矛盾的约束（如同时设置equalTo和lessThanOrEqualTo但数值冲突）
- **参考节点循环检测**：防止约束引用形成循环依赖
- **冲突解决策略**：优先级排序（尺寸约束 > 边界约束 > 中心约束），提供自动解决建议

### 3. 约束系统：约束包设计
**决策**：采用约束包系统管理布局约束，参考 iOS SnapKit 库设计
- 每个节点支持多个约束包，便于约束方案切换
- 约束包包含完整的约束类型：
  - **尺寸约束**：height、width
  - **边界约束**：top、left、right、bottom、leading、trailing
  - **中心约束**：centerX、centerY
  - **基线约束**：baseline（文本组件垂直对齐）
  - **宽高比约束**：aspectRatio（保持组件比例）
- 支持约束关系：equalTo、greaterThanOrEqualTo、lessThanOrEqualTo
- 默认约束包用于模拟器渲染和布局计算

**替代方案**：
- 单一约束数组：难以管理复杂的约束组合
- 固定约束模板：灵活性不足
- 仅基础约束：无法支持国际化布局和文本对齐

**理由**：提供完整的约束管理，支持国际化布局、文本对齐和比例保持等高级布局需求

### 4. 节点 ID 系统：层级编码
**决策**：采用 "030201" 格式的自动生成系统
- 根节点：两位数字（01, 02, 03...）
- 子节点：两位数字（0101, 0102...）
- 自动处理节点增删时的 ID 更新

**替代方案**：
- UUID：难以体现层级关系
- 自增 ID：无法体现父子关系

### 5. 状态管理：观察者模式
**决策**：使用观察者模式实现数据同步
- 中央状态管理器维护数据
- 各模块订阅状态变化
- **移除撤销/重做功能**：改为通过修改日志系统提供历史记录查看

**理由**：简单可靠，适合原生 JavaScript 项目，通过修改日志提供审计追踪而非撤销重做

### 6. AI 聊天助手交互设计
**决策**：采用三栏布局的 AI 聊天助手，提供完整的上下文感知和修改日志功能
- **三栏布局设计**：
  - 聊天历史区域（55%）：显示用户和AI的对话历史，支持滚动和消息交互
  - 配置和上下文面板（25%）：显示服务器配置、AI设置和当前选中节点信息
  - 修改日志面板（20%）：记录所有AI修改的历史，支持搜索、筛选和导出
- **当前选中节点显示和传递**：
  - 实时显示当前在树形编辑器中选择的节点ID和名称
  - 自动将选中节点信息传递给AI作为上下文：`selected_node` 字段包含节点ID、名称和类型
  - 支持节点引用语法：在聊天中使用 `@节点ID` 或 `@节点名称` 引用特定节点
- **命令逐一确认执行**：
  - AI返回修改命令时弹出确认对话框，展示所有待执行命令
  - 支持逐一确认：用户可逐个命令确认执行或跳过
  - 支持批量确认：一次性执行所有命令
  - 每个命令执行前展示修改前后对比，确保用户了解变更内容
- **修改日志系统**：
  - 记录所有AI修改的历史，包括时间戳、命令类型、目标节点、执行状态
  - 支持按节点ID、命令类型、时间范围搜索和筛选
  - 提供日志导出功能（JSON/CSV格式）
  - 日志详情查看：显示完整的命令数据和修改前后对比
- **AI请求数据格式增强**：
```json
{
  "json_data": {完整的UI结构JSON},
  "json_spec": "JSON规范描述",
  "question": "用户的问题",
  "selected_node": {
    "nodeId": "030201",
    "nodeName": "按钮组件",
    "nodeType": "UIButton",
    "isSelected": true
  },
  "conversation_history": []
}
```
- **移除撤销重做功能**：改为提供完整的修改日志，用户通过日志查看历史修改

**替代方案**：
- 单一聊天界面：无法提供足够的上下文信息和修改追踪
- 自动执行无确认：用户控制权不足，可能导致意外修改
- 撤销重做系统：复杂度高，改为日志系统更直观

**理由**：提供完整的上下文感知能力，确保AI理解用户当前关注的UI组件，通过逐一确认和修改日志平衡自动化效率和用户控制权

### 7. 命令执行引擎
**决策**：实现命令执行引擎来处理AI返回的修改命令
- 支持多种操作类型：update_node, add_node, remove_node, reorder_nodes
- 命令格式标准化，确保前后端一致性
- 修改确认机制，防止意外修改
- 自动刷新树形编辑器、模拟器和属性编辑器

**替代方案**：
- 手动应用修改：用户体验较差
- 自动应用无确认：可能导致意外修改

**理由**：平衡自动化效率和用户控制权

### 8. Electron 主进程和 AI 配置系统
**决策**：使用 Electron 主进程处理 AI 服务和应用生命周期
- 主进程处理窗口管理、文件系统操作和 AI 服务集成
- 渲染进程专注于前端 UI 展示，通过 IPC 与主进程通信
- 直接连接第三方 AI 服务，简化架构
- 支持前端配置 API Key 和模型选择
- API Key 使用 Electron safeStorage 安全存储
- 提供模型发现功能，从第三方 AI 服务获取可用模型列表
- 处理 AI 聊天请求和结构化命令生成

**替代方案**：
- Python Flask 后端：需要额外运行 Python 服务，部署复杂
- 直接前端调用 OpenAI：跨域限制和安全性问题

**理由**：提供完整的桌面应用体验，简化部署，增强安全性，适合跨平台分发

### 9. API 端点设计
**决策**：设计简化的 RESTful API 端点
- `GET /` - 前端主页面
- `POST /api/ai/chat` - AI 聊天端点，处理 UI 设计问题
- `GET /api/health` - 服务健康检查端点
- `POST /api/ai/config` - AI 配置管理端点
- `GET /api/ai/models` - 获取可用 AI 模型列表
- `POST /api/ai/test` - 连接测试端点

**API 详细设计**：
- **AI 聊天端点** (`POST /api/ai/chat`)：
  - 请求体：包含完整的UI结构JSON、JSON规范描述、用户问题和选中节点信息
  - 响应体：包含AI建议和结构化修改命令
  - 超时设置：60秒
  - 错误处理：返回标准错误格式和重试建议

- **配置管理端点** (`POST /api/ai/config`)：
  - 支持动态更新API Key、模型选择和服务器地址
  - 配置验证：验证API Key格式和服务器连通性
  - 安全存储：配置仅保存在内存中

- **模型发现端点** (`GET /api/ai/models`)：
  - 从第三方AI服务获取可用模型列表
  - 缓存机制：5分钟缓存避免频繁请求
  - 模型信息：包含模型ID、名称、能力和限制

**理由**：提供简化的前后端通信接口，适合本地工具使用，同时确保API设计的完整性和可扩展性

### 10. AI 服务集成
**决策**：通过 Electron 主进程直接调用兼容 OpenAI 接口的 AI 服务
- 配置 AI 服务地址，支持任意兼容 OpenAI 接口的服务
- 使用 HTTP 请求直接调用 AI 服务，无需中间层
- 设计专门的系统提示词理解 UI 结构
- 生成标准化的修改命令格式
- 支持温度、最大令牌数等参数配置
- 在主进程中处理所有 AI 请求，确保安全性

**理由**：简化架构，直接使用兼容 OpenAI 接口的服务，避免复杂的后端部署，保持桌面应用的安全性和性能

### 11. 渲染引擎：CSS 转换
**决策**：使用 CSS 实现 iOS 风格渲染
- 将节点属性转换为 CSS 样式
- 使用 Flexbox 实现约束布局
- 支持约束包的实时渲染和切换
- 支持AI修改后的自动刷新
- **仅用于静态 Web 预览，不处理任何用户交互**
- **仅用于 Web 预览，不生成真实 iOS 代码**

**替代方案**：
- Canvas 渲染：实现复杂，难以编辑
- SVG 渲染：不适合复杂 UI 层级
- iOS 原生渲染：超出项目范围

**理由**：专注于 JSON 数据结构的可视化编辑和输出，不涉及代码生成和交互逻辑

## Risks / Trade-offs

### 风险 1：性能问题
- **风险**：复杂 UI 层级树（超过500个节点）可能导致渲染性能下降，响应时间超过100ms目标
- **影响**：用户体验下降，编辑操作卡顿
- **缓解**：
  - 实现性能监控和警告机制，当节点数量接近1000个时提醒用户
  - **可选优化措施**：
    - 虚拟滚动，只渲染可见区域的节点
    - 懒加载技术，延迟加载非活动节点的详细数据
    - 增量更新策略，只更新发生变化的部分
- **性能监控指标**：
  - **树形编辑器响应时间**：节点展开/折叠、选择、拖拽操作 < 50ms
  - **属性编辑器同步时间**：节点选择到属性显示 < 30ms
  - **模拟器渲染时间**：根节点切换或属性修改后渲染 < 100ms
  - **AI聊天响应时间**：AI请求到响应 < 5秒
  - **内存使用监控**：1000个节点时内存使用 < 500MB
- **验收标准**：在1000个节点的场景下，主要操作响应时间保持在100ms以内

### 风险 2：数据一致性
- **风险**：多面板同时编辑可能导致数据不一致，特别是AI修改与用户手动编辑的冲突
- **影响**：数据损坏，UI状态异常
- **缓解**：
  - 实现中央状态管理器，统一管理所有数据变更
  - 使用事务性操作，确保编辑操作的原子性
  - 实现冲突检测和解决机制，特别是AI修改与手动编辑的冲突
  - 自动保存和版本历史，支持回滚到之前的状态
- **验收标准**：在任何编辑场景下，所有面板的数据保持实时同步

### 风险 3：浏览器兼容性
- **风险**：现代 CSS 特性（如Grid、Flexbox高级特性）在旧浏览器中不支持
- **影响**：模拟器渲染效果不一致，布局计算错误
- **缓解**：
  - 明确支持现代浏览器（Chrome 90+、Firefox 88+、Safari 14+、Edge 90+）
  - 使用特性检测和渐进增强策略
  - 提供基础CSS降级方案，确保核心功能可用
  - 详细的浏览器兼容性文档和测试矩阵
- **验收标准**：在支持的浏览器中，所有功能正常工作，模拟器渲染准确

### 风险 4：AI 命令执行安全
- **风险**：AI生成的修改命令可能包含无效或破坏性操作
- **影响**：数据损坏，UI结构破坏
- **缓解**：
  - 严格的命令格式验证，确保所有字段符合规范
  - 命令执行前的用户确认机制，展示修改前后的对比
  - 命令执行引擎的沙箱环境，限制破坏性操作的范围
  - 完整的撤销/重做系统，支持回退AI修改
- **验收标准**：AI命令执行前必须经过用户确认，支持完整的撤销操作

### 风险 5：数据格式版本兼容性
- **风险**：JSON数据格式变更导致旧版本数据无法导入
- **影响**：用户数据丢失，迁移成本增加
- **缓解**：
  - 定义清晰的数据版本管理策略
  - 实现数据迁移工具，自动将旧版本数据升级到新格式
  - 保持向后兼容性，至少支持最近3个主要版本的数据导入
  - 详细的版本变更日志和迁移指南
- **验收标准**：支持从v1.0格式的数据导入和自动升级

## 迁移计划
1. **阶段 1**：实现基础四区域布局和树形编辑器
2. **阶段 2**：添加模拟器和属性编辑器
3. **阶段 3**：实现数据管理和高级功能
4. **阶段 4**：优化性能和用户体验

## Open Questions
- JSON 格式是否需要进一步标准化？
- 如何处理复杂的约束关系计算？
- 是否需要支持组件库和模板功能？
